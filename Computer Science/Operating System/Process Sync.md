## 프로세스 동기화

<br>

공유된 자원에 여러 프로세스가 동시에 접근하면서 자원의 일관성을 해치는 문제가 발생할 수 있다. 
이때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 것이 **동기화**라고 한다.

<br>

### Race Condition

공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태

> 동시 접근 시 자료의 일관성을 해치는 결과가 나타남

<br>

#### Race Condition이 발생하는 경우

1. ##### 커널 작업을 수행하는 중에 인터럽트 발생

    - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
    - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.

2. ##### 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때

    - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
    - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함

3. ##### 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때

    - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
    - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법




<br>

### 임계 구역(Critical Section)

> 여러 프로세스가 데이터를 공유하며 수행될 때, **동일한 자원에 동시에 접근하는 경우가 발생하는 코드 영역**

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.

<br>

#### CSP(Critical Section Problem) 해결법
세가지 모두 만족해야 함
- **Mutual Exclusion (상호배타)** : 오직 한 쓰레드만 진입
- **Progress (진행)** : 임계구역을 사용하고 있지 않다면 다른 프로세스가 접근할 수 있도록 한다
- **Bounded Waiting (유한 대기)** : 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.
  - 임계구역 진입횟수에 한계를 두어 같은 프로세스가 계속해서 독점해서 사용하지 못하게 한다. -> 다른 프로세스들이 기아상태에 빠지지 않게 한다

<br>

### 1. 뮤텍스 락 (Mutex Locks) 

**뮤텍스** : 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술

> 즉, 이미 하나의 프로세스가 Critical Section에서 작업 중이면 다른 프로세스들은 Critical Section에 들어갈 수 없도록 한다.
> 
> 뮤텍스는 상태가 0, 1로 **이진 세마포어**로 부르기도 함

해당 접근을 조율하기 위해 lock과 unlock을 사용한다.

- lock : 현재 임계 구역에 들어갈 권한을 얻어옴 ( 만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기 )
- unlock : 현재 임계 구역을 모두 사용했음을 알림. ( 대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음 )

<br>

#### 뮤텍스 단점

- Busy Wating : Critical Section에 프로세스가 존재할 때 다른 프로세스들은 계속해도 진입을 시도 → CPU 낭비

  - = **Spin Lock** : lock이 반환될 때까지 계속 확인하며 프로세스를 기다리는 것

  - → **Critical Section에 진입을 위한 대기 시간이 짧을 때, 즉 Context Switching 하는 비용보다 기다리는 게 더 효율적인 특수한 상황을 위해 고안된 것.**


- 멀티 프로레서 시스템에서 유용 (단일 cpu : lock 스레드를 풀어주기 위해 Context Switching이 일어나야 함)


<br>

#### **뮤텍스 알고리즘**

1. ##### 데커(Dekker) 알고리즘

   flag와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식

    - flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
    - turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수

   ```java
   while(true) {
       flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
       while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
           if(turn == j) { // j가 임계 구역 사용 중이면
               flag[i] = false; // 프로세스 i 진입 취소
               while(turn == j); // turn이 j에서 변경될 때까지 대기
               flag[i] = true; // j turn이 끝나면 다시 진입 시도
           }
       }
   }
   
   // ------- 임계 구역 ---------
   
   turn = j; // 임계 구역 사용 끝나면 turn을 넘김
   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
   ```

   <br>

2. ##### 피터슨(Peterson) 알고리즘

   데커와 유사하지만, 상대방 프로세스/스레드에게 진입 기회를 양보하는 것에 차이가 있음

   ```java
   while(true) {
       flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
       turn = j; // 다른 프로세스에게 진입 기회 양보
       while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
       }
   }
   
   // ------- 임계 구역 ---------
   
   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
   ```

   <br>

3. ##### 제과점(Bakery) 알고리즘

   여러 프로세스/스레드에 대한 처리가 가능한 알고리즘. 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다.

   ```java
   while(true) {
       
       isReady[i] = true; // 번호표 받을 준비
       number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 
       isReady[i] = false; // 번호표 수령 완료
       
       for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
           while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
           while(number[j] && number[j] < number[i] && j < i);
           
           // 프로세스 j가 번호표 가지고 있어야 함
           // 프로세스 j의 번호표 < 프로세스 i의 번호표
       }
   }
   
   // ------- 임계 구역 ---------
   
   number[i] = 0; // 임계 구역 사용 종료
   ```

<br>

### 2. 세마포어 (Semaphores)
Busy Waiting이 필요없는 동기화 도구이며, 여러 프로세스나 스레드가 Critical Section에 진입할 수 있는 Signaling 매커니즘이다.

> Counter 이용 → 동시에 자원에 접근할 수 있는 프로세스를 제한함

<br>

#### 세마포어 두 종류
> Counting 세마포어 : 정수 값의 범위가 0 이상으로 제한이 없다. 주로 자원의 개수를 세는 데 사용한다.
>
> Binary 세마포어 : 정수 값이 오직 0 또는 1이다. Mutex lock과 동일한 역할을 갖는다.
 [Mutex lock과의 차이점?]

<br>

#### Block & Wakeup 방식 사용
> Busy Waiting 방지!
>
> **Critical Section으로의 진입에 실패한 프로세스를 기다리게 하지 않고 Block 시킨 뒤 Critical Section에 자리가 나면 다시 깨워줌으로써** Busy waiting에서의 CPU 낭비 문제를 해결해준다.
>
> Critical Section이 매우 짧은 경우 비효율적

<br>

#### 세마포어 P, V 연산

P : 임계 구역 들어가기 전에 수행 (프로세스 진입 여부를 자원의 개수(S)를 통해 결정)

V : 임계 구역에서 나올 때 수행 (자원 반납 알림, 대기 중인 프로세스를 깨우는 신호)

<br>

##### 구현 방법

```sql
P(S);

// --- 임계 구역 ---

V(S);
```

<br>

```sql
procedure P(S)   --> 최초 S값은 1임
    while S=0 do wait  --> S가 0면 1이 될때까지 기다려야 함
    S := S-1   --> S를 0로 만들어 다른 프로세스가 들어 오지 못하도록 함
end P

--- 임계 구역 ---

procedure V(S) --> 현재상태는 S가 0임
    S := S+1   --> S를 1로 원위치시켜 해제하는 과정
end V
```

이를 통해, 한 프로세스가 P 혹은 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다. P와 V를 사용하여 임계 구역에 대한 상호배제 구현이 가능하게 되었다.

***예시***

> 최초 S 값은 1이고, 현재 해당 구역을 수행할 프로세스 A, B가 있다고 가정하자

1. 먼저 도착한 A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어감
2. 그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기 상태
3. A가 임계구역 수행을 마치고 V(S)를 실행하면 S는 다시 1이 됨
4. B는 이제 P(S)에서 while문을 빠져나올 수 있고, 임계구역으로 들어가 수행함

<br>

### 3. Monitor

동시 수행 중인 **프로세스 사이에서 추상 데이터의 안전한 공유를 보장하기 위한 High-level 동기화 구조이다.** 

- 세마포어 : 어셈블리어 / 모니터 : 하이레벨 언어
- 공유 데이터를 접근하기 위해서는 **모니터의 내부 Procedure**를 통해서만 접근할 수 있도록 한다.

> 세마포어와의 가장 큰 차이점
> 
> 모니터 : 락(Lock)을 걸 필요가 없다.
> 
> 세마포어는 : 프로그래머가 직접 wait와 signal을 사용하여 Race condition을 해결해야 하지만 모니터는 자체적인 함수로 해결할 수 있게 된다.

<br>

### 자바에서의 동기화 처리
synchronized 키워드

이 임계영역에 synchronized 키워드를 사용하여 여러 스레드가 동시에 접근하는 것을 금지함으로써 동기화를 할 수 있다.

<br>

#### synchronized
synchronized로 지정된 임계영역은 한 스레드가 이 영역에 접근하여 사용할때 lock이 걸림으로써 다른 스레드가 접근할 수 없게 된다. 

이후 해당 스레드가 이 임계영역의 코드를 다 실행 후 벗어나게되면 unlock 상태가 되어 그때서야 대기하고 있던 다른 스레드가 이 임계영역에 접근하여 다시 lock을 걸고 사용할 수 있게 된다.

> lock은 해당 객체당 하나씩 존재하며, synchronized로 설정된 임계영역은 lock 권한을 얻은 하나의 객체만이 독점적으로 사용하게 된다.

```
// 예시
public class HelloWorld {
	public static void main(String[] args) {
		StringDisplay sd = new StringDisplay();
		MyThread[] mts = new MyThread[5];
		for (int i=0; i<mts.length; i++) {
			mts[i] = new MyThread(sd, Integer.toString(i));	
			mts[i].start();
		}
	}
}

class StringDisplay {
	synchronized void display(String s) {
		for (int i=0; i<5; i++) {
			System.out.print(s);
		}
		System.out.println("");
	}
}

class MyThread extends Thread {
	StringDisplay sd;
	String s = "";
	
	public MyThread(StringDisplay sd, String s) {
		this.sd = sd;
		this.s = s;
	}
	
	@Override
	public void run() {
		sd.display(s);
	}
}

[실행결과]
00000
22222
11111
44444
33333
```

<br>

### 뮤텍스 vs 세마포어

> 1. 동기화 대상의 개수 :
>Mutex는 동기화 대상이 only 1개일 때 사용
>Semaphore는 동기화 대상이 1개 이상일 때 사용
>
> 
>2. 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.
>Mutex는 0,1로 이루어진 이진 상태이므로 Binary Semaphore
>
> 
>3. Mutex는 자원 소유가능 + 책임을 가지는 반면 Semaphore는 자원 소유가 불가하다.
>
> 
>4. Mutex는 소유하고 있는 스레드 만이 이 Mutex를 해제할 수 있다.
>반면, Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있다.
>
> 
>5. Semaphore는 시스템 범위에 걸쳐 있고 파일 시스템 상의 파일로 존재한다.
>반면 Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up된다.

<br>

### 세마포어 vs 모니터
> 모니터는 락(Lock)을 걸 필요가 없다. 