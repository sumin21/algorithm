# CPU Scheduling

<br>

### 1. 스케줄링

> 메모리에 있는 프로세스들 중 어떤 프로세스를 실행할지 선택하고 CPU를 할당하는 역할.
> - CPU, 자원을 효율적으로 사용하기 위함
> - 멀티 프로그래밍에서 CPU 이용률을 극대화하기 위함

- 조건 : 오버헤드 ↓ / 사용률 ↑ / 기아 현상 ↓
- 목표
    1. `Batch System`: 가능하면 많은 일을 수행. 시간(time) 보단 처리량(throughout)이 중요
    2. `Interactive System`: 빠른 응답 시간. 적은 대기 시간.
    3. `Real-time System`: 기한(deadline) 맞추기.

### 2. 장기 / 중기 / 단기 스케줄링
- 장기 스케줄링
  - 디스크와 메모리 사이의 스케줄링
  - 디스크에서 프로그램을 가져와 메모리를 할당해, 프로세스를 준비큐에 등록하는 역할
  - I/O가 자주 필요한 프로세스들은 시간이 오래 걸리며, 이런 프로세스들만 올라가면 CPU 사용이 비효율적이다. 따라서 적절히 섞어 올려준다.
- 중기 스케줄링
  - 너무 많은 프로세스가 메모리에 올라왔을 때, 이를 다시 디스크로 보내는 역할
  - 메모리에 여유 X -> 대기 상태 프로세스를 먼저 스왑아웃 -> 그래도 부족 -> 타이머 인터럽트 발생 -> 준비큐로 이동하는 프로세스를 스왑아웃
  - 메모리에 여유 -> 스왑인
    - 스왑아웃 : 프로세스 메모리를 뺏어 디스크 스왑 영역으로 보냄
    - 스왑인 : 디스크 스왑 영역에서 다시 메모리로
- 단기 스케줄링
  - 메모리와 CPU 사이의 스케줄링
  - 준비큐에서 어떤 프로세스를 실행할지 결정한다.
  - 아주 짧은 시간으로 쪼개 스케줄링 -> 사용자들에게는 여러 프로세스가 동시에 실행되는 것처럼 보여진다.

### 3. 프로세스 상태

![download (5)](https://user-images.githubusercontent.com/13609011/91695344-f2dfae80-eba8-11ea-9a9b-702192316170.jpeg)

---

**프로세스의 상태 전이**

✓ **승인 (Admitted)** : 프로세스 생성이 가능하여 승인됨.

✓ **스케줄러 디스패치 (Scheduler Dispatch)** : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.

✓ **인터럽트 (Interrupt)** : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것.

✓ **입출력 또는 이벤트 대기 (I/O or Event wait)** : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.

✓ **입출력 또는 이벤트 완료 (I/O or Event Completion)** : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것.

### 4. 선점 / 비선점 스케줄링

- 선점 (preemptive) : 프로세스가 CPU를 할당받아 실행 중이더라도 OS가 강제로 뺏을 수 있음 (우선순위 중요)
  - 장점
    - CPU 처리 기간이 매우 긴 프로세스의 CPU 사용독점을 막을 수 있다. (효율적인 운영)
    - 빠른 응답시간 요하는 대화식 시분할 시스템에 적합하다. (긴급 프로세스 제어 가능)
  - 단점
    - 잦은 문맥교환 -> 오버헤드 (효과적으로 이용하려면 메모리가 프로세스에 많이 적재되어 있어야 한다.)
    - 처리시간 예측 어려움

  
- 비선점 (nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장
  - 장점
    - 필요한 문맥교환만 발생 -> 오버헤드 적다.
    - 일괄처리 시스템에 적합
    - 처리시간 예측 용이함
  - 단점
    - 프로세스 배치에 따라 효율성 차이가 크다 (융통성 X)

- CPU 스케줄러가 스케줄링 결정하는 상황
  - 대기 -> 준비로 전환 (선점 스케줄링)
  - 실행 -> 준비로 전환 (선점 스케줄링)
  - 실행 -> 대기로 전환 (선점 스케줄링, 비선점 스케줄링)
  - 종료 (선점 스케줄링, 비선점 스케줄링)

### 4. CPU 스케줄링의 종류

- 비선점 스케줄링
    1. FCFS (First Come First Served)
        - 준비큐에 도착한 순서대로 CPU 할당
        - 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐
        - 공정성, 간단
        - 융통성 X
    2. SJF (Shortest Job First)
        - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
        - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리
        - 기아 현상 발생
    3. HRN (Hightest Response-ratio Next)
        - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)
        - 우선순위 = (대기시간 + 실행시간) / (실행시간)
        - 우선순위 높은 P부터 할당 (실행시간 짧고, 대기시간 큰 P 우선)

- 선점 스케줄링
    1. Priority Scheduling
        - 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
        - 우선 순위가 낮은 프로세스가 무한정 기다리는 기아현상(Starvation)이 생길 수 있음
        - Aging 방법으로 기아 문제 해결 가능
       > Aging 기법 : 시간이 지날수록 P 우선순위 상승시켜줌
    2. RR (Round Robin)
        - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 `Time Quantum` 만큼 CPU를 할달 받음
            - `Time Quantum` or `Time Slice` : 실행의 최소 단위 시간
        - 할당 시간(`Time Quantum`)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
    3. SRTF
        - 실행중인 P의 남은 실행시간과 준비큐에 새로 들어온 P의 실행시간을 비교하여 더 짧은 시간부터 할당
        - 모든 P 실행시간을 추적/보유 -> 오버헤드 큼
        - 기아 현상 발생 (긴 시간의 P)
    4. MLQ (Multilevel-Queue) (다단계 큐)

       ![Untitled1](https://user-images.githubusercontent.com/13609011/91695428-16a2f480-eba9-11ea-8d91-17d22bab01e5.png)
        - 준비큐를 여러 개의 큐로 나누어 각각 스케줄링 알고리즘을 적용하는 기법
        - 큐 사이 이동 못함 (스케줄링 부담이 적다. 유연성이 낮다. 기아 현상)
        - 보통 Foreground P는 RR을, Background P는 FCFS를 적용한다.
          ![Untitled](https://user-images.githubusercontent.com/13609011/91695480-2a4e5b00-eba9-11ea-8dbf-390bf0a73c10.png)

        - 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용
        - 우선순위가 높은 큐는 작은 `Time Quantum` 할당. 우선순위가 낮은 큐는 큰 `Time Quantum` 할당.
    5. MFQ (Multilevel-Feedback-Queue) (다단계 피드백 큐)

       ![Untitled2](https://user-images.githubusercontent.com/13609011/91695489-2cb0b500-eba9-11ea-8578-6602fee742ed.png)

        - 큐 사이 이동이 가능하다.
        - 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고 자신의 `Time Quantum`을 다 채우지 못한 프로세스는 원래 큐 그대로
            - Time Quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
        - 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
        - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌
        - 에이징 기법 : 맨 아래 큐에서 너무 오래 대기 -> 상위 큐로 이동 (기아 현상 예방)

### 5. CPU 스케줄링 척도

1. CPU 이용률(CPU utilization)시간당 CPU를 사용한 시간의 비율
   - 프로세서를 실행상태로 항상 유지하려고 해야 한다.
2. 처리율(Throughput)
   - 시간당 처리한 작업의 비율
   - 단위 시간당 완료되는 작업 수가 많도록 해야 한다.
3. 반환시간(Turnaround Time)
   - 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
   - 작업이 준비 큐(ready queue)에서 기다린 시간부터 CPU에서 실행된 시간, I/O 작업 시간의 합이다.
4. 대기시간(Waiting Time)
   - 대기열에 들어와 CPU를 할당받기 까지 기다린 시간
   - 준비 큐에서 기다린 시간의 총합
5. 반응시간(Response Time)
   - 대기열에서 처음으로 CPU를 얻을 때까지 걸린 시간
   - 대기시간과 비슷하지만 다른 점은, 대기시간은 준비 큐에서 기다린 모든 시간을 합친 것이지만 반응 시간은 CPU를 할당받은 최초의 순간까지 기다린 시간 한번 만을 측정한다.

-> CPU 이용률과 처리율은 극대화하는 것이 좋고 반환시간, 대기시간, 반응시간은 줄이는 것이 일반적으로 좋다.

---

### 출처

- 스케줄링 목표 : [링크](https://jhnyang.tistory.com/29?category=815411)
- 프로세스 전이도 그림 출처 : [링크](https://rebas.kr/852)
- CPU 스케줄링 종류 및 정의 참고 : [링크](https://m.blog.naver.com/PostView.nhn?blogId=so_fragrant&logNo=80056608452&proxyReferer=https:%2F%2Fwww.google.com%2F)
- 다단계큐 참고 : [링크](https://jhnyang.tistory.com/28)
- 다단계 피드백 큐 참고 : [링크](https://jhnyang.tistory.com/156)